<!DOCTYPE html>
<html>

<head>
<title>Oasis - Water Ripples and Sand Scene</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>

<script>
// Vertex shader for both quads
var VSHADER_SOURCE = `
  attribute vec4 a_Position;
  uniform mat4 u_ViewMatrix;
  uniform mat4 u_ProjMatrix;
  varying vec4 v_Position;
  
  void main() {
    gl_Position = u_ProjMatrix * u_ViewMatrix * a_Position;
    v_Position = a_Position;
  }`;

// Fragment shader for water ripple
var FSHADER_WATER = `
  precision mediump float;
  varying vec4 v_Position;
  uniform float u_Time;
  
  void main() {
    vec2 vP = v_Position.xy;
    float dist = length(vP);
    
    // Animated ripple effect using sin and time
    float ripple = sin(dist * 10.0 - u_Time * 2.0) * 0.5 + 0.5;
    
    // Create concentric circles that fade
    ripple = ripple * (1.0 - dist);
    
    // Water color with ripple intensity
    vec3 waterColor = vec3(0.0, 0.3, 0.6) + vec3(ripple * 0.3);
    
    // Optional: For transparency (extra credit)
    // Set alpha based on ripple intensity
    float alpha = 0.3 + ripple * 0.7;
    
    gl_FragColor = vec4(waterColor, alpha);
  }`;

// Fragment shader for sand texture
var FSHADER_SAND = `
  precision mediump float;
  varying vec4 v_Position;
  
  vec3 permute(vec3 x){ 
    return mod(((x*34.0)+1.0)*x, 289.0); 
  } 

  vec3 taylorInvSqrt(vec3 r){ 
    return 1.79284291400159 - 0.85373472095314 * r; 
  } 

  float noise(vec2 P){ 
    const vec2 C = vec2(0.21132486540518713, 0.36602540378443859); 
    vec2 i = floor(P + dot(P, C.yy) );
    vec2 x0 = P - i + dot(i, C.xx);  
    vec2 i1;  
    i1.x = step( x0.y, x0.x );  
    i1.y = 1.0 - i1.x;  
    vec4 x12 = x0.xyxy +  vec4( C.xx, C.xx * 2.0 - 1.0);  
    x12.xy -= i1;  
    i = mod(i, 289.0);  
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));  
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);  
    m = m*m;  
    m = m*m;  
    vec3 x = fract(p*(1.0/41.0)) * 2.0 - 1.0;  
    vec3 gy = abs(x)-0.5;  
    vec3 ox = floor(x + 0.5);  
    vec3 gx = x - ox;  
    m *= taylorInvSqrt( gx*gx + gy*gy );  
    vec3 g;  
    g.x = gx.x * x0.x + gy.x * x0.y;  
    g.yz = gx.yz * x12.xz + gy.yz * x12.yw;  
    return 130.0 * dot(m, g);  
  }  

  float turb(float cx, float cy){  
     return .5 * noise(vec2(cx,cy)) + .25 
         * noise(vec2(2.0*cx,2.0*cy)) + .125 
         * noise(vec2(4.0*cx,4.0*cy));  
  }

  void main(){
    float cx = v_Position.x;
    float cy = v_Position.y;
    float m = (1.0 + sin((cx + turb(cx,cy) * 2.0) * 5.0)) * .5;
    float n = noise(vec2(cx*200.0,cy*200.0)); 
    m = (m + n) * .1;
    gl_FragColor = vec4(.9+m,.8*.9+m,.5*.9+m, 1.0);
  }`;

// Global variables
var gl;
var waterProgram, sandProgram;
var TIME = 0.0;
var cameraX = 0.0;
var cameraZ = 5.0;

function main() {
  // Get canvas and WebGL context
  var canvas = document.getElementById('webgl');
  gl = getWebGLContext(canvas);
  
  if (!gl) {
    console.log('Failed to get WebGL context');
    return;
  }
  
  // Enable depth testing and transparency
  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  
  // Set clear color
  gl.clearColor(0.1, 0.2, 0.4, 1.0);
  
  // Initialize shaders for water
  waterProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_WATER);
  if (!waterProgram) {
    console.log('Failed to create water program');
    return;
  }
  
  // Initialize shaders for sand
  sandProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SAND);
  if (!sandProgram) {
    console.log('Failed to create sand program');
    return;
  }
  
  // Set up vertex buffers
  initVertexBuffers();
  
  // Set up keyboard controls
  document.onkeydown = function(ev) { keydown(ev); };
  
  // Start animation loop
  tick();
}

function initVertexBuffers() {
  // Create vertices for sand quad (bottom, horizontal)
  var sandVertices = new Float32Array([
    -2.0, -1.0, -2.0,
    -2.0, -1.0,  2.0,
     2.0, -1.0, -2.0,
     2.0, -1.0,  2.0
  ]);
  
  // Create vertices for water quad (vertical, standing)
  var waterVertices = new Float32Array([
    -1.5,  1.5, 0.0,
    -1.5, -0.5, 0.0,
     1.5,  1.5, 0.0,
     1.5, -0.5, 0.0
  ]);
  
  // Create buffers for sand
  sandProgram.vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, sandProgram.vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, sandVertices, gl.STATIC_DRAW);
  
  // Create buffers for water
  waterProgram.vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, waterProgram.vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, waterVertices, gl.STATIC_DRAW);
}

function tick() {
  TIME += 0.01;
  draw();
  requestAnimationFrame(tick);
}

function draw() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  // Set up view matrix (camera looking at center)
  var viewMatrix = new Matrix4();
  viewMatrix.setLookAt(
    cameraX, 2.0, cameraZ,  // Eye position
    0.0, 0.0, 0.0,          // Look at center
    0.0, 1.0, 0.0           // Up vector
  );
  
  // Set up projection matrix
  var projMatrix = new Matrix4();
  projMatrix.setPerspective(45, 1, 0.1, 100);
  
  // Draw sand quad
  gl.useProgram(sandProgram);
  
  // Set uniforms for sand
  var u_ViewMatrix = gl.getUniformLocation(sandProgram, 'u_ViewMatrix');
  var u_ProjMatrix = gl.getUniformLocation(sandProgram, 'u_ProjMatrix');
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
  gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
  
  // Bind sand vertices
  gl.bindBuffer(gl.ARRAY_BUFFER, sandProgram.vertexBuffer);
  var a_Position = gl.getAttribLocation(sandProgram, 'a_Position');
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Position);
  
  // Draw sand
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  // Draw water quad
  gl.useProgram(waterProgram);
  
  // Set uniforms for water
  u_ViewMatrix = gl.getUniformLocation(waterProgram, 'u_ViewMatrix');
  u_ProjMatrix = gl.getUniformLocation(waterProgram, 'u_ProjMatrix');
  var u_Time = gl.getUniformLocation(waterProgram, 'u_Time');
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
  gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
  gl.uniform1f(u_Time, TIME);
  
  // Bind water vertices
  gl.bindBuffer(gl.ARRAY_BUFFER, waterProgram.vertexBuffer);
  a_Position = gl.getAttribLocation(waterProgram, 'a_Position');
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Position);
  
  // Draw water
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// Camera controls
function moveForward() {
  cameraZ -= 0.5;
}

function moveBack() {
  cameraZ += 0.5;
}

function moveLeft() {
  cameraX -= 0.5;
}

function moveRight() {
  cameraX += 0.5;
}

function keydown(ev) {
  switch(ev.keyCode) {
    case 38: // Up arrow
      moveForward();
      break;
    case 40: // Down arrow
      moveBack();
      break;
    case 37: // Left arrow
      moveLeft();
      break;
    case 39: // Right arrow
      moveRight();
      break;
  }
}

// Helper function to create shader program
function createProgram(gl, vShader, fShader) {
  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vShader);
  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fShader);
  
  if (!vertexShader || !fragmentShader) {
    return null;
  }
  
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log('Failed to link program: ' + gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  
  return program;
}

function loadShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log('Failed to compile shader: ' + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  
  return shader;
}
</script>

</head>

<body onload="main();">

<canvas id="webgl" width="400" height="400"></canvas>

<br>

<button type="button" onclick="moveForward()">Forward</button>
<button type="button" onclick="moveBack()">Back</button>
<button type="button" onclick="moveLeft()">Left</button>
<button type="button" onclick="moveRight()">Right</button>

</body>
</html>