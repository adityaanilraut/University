<!DOCTYPE html>
<html>
<head>
<title>Cones of Dunshire</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>

<style>
body {
    font-family: Arial, sans-serif;
    margin: 20px;
}
.slider-container {
    margin: 10px 0;
}
.slider-container label {
    display: inline-block;
    width: 120px;
}
</style>

</head>

<body onload="main();">

<h2>Sphere Cylinder and Cone</h2>

<canvas id="webgl" width="600" height="600"></canvas>

<br><br>

<h3>Light 1 Position (White)</h3>
<div class="slider-container">
    
    <label>X Position:</label>
    <input type="range" id="lightX" min="-5" max="5" step="0.1" value="2">
    <span id="lightXValue">2.0</span>
</div>
<div class="slider-container">
    <label>Y Position:</label>
    <input type="range" id="lightY" min="-5" max="5" step="0.1" value="3">
    <span id="lightYValue">3.0</span>
</div>
<div class="slider-container">
    <label>Z Position:</label>
    <input type="range" id="lightZ" min="-5" max="5" step="0.1" value="3">
    <span id="lightZValue">3.0</span>
</div>

<h3>Light 1 Color </h3>
<div class="slider-container">
    <label>Red:</label>
    <input type="range" id="colorR" min="0" max="1" step="0.01" value="1">
    <span id="colorRValue">1.0</span>
</div>
<div class="slider-container">
    <label>Green:</label>
    <input type="range" id="colorG" min="0" max="1" step="0.01" value="1">
    <span id="colorGValue">1.0</span>
</div>
<div class="slider-container">
    <label>Blue:</label>
    <input type="range" id="colorB" min="0" max="1" step="0.01" value="1">
    <span id="colorBValue">1.0</span>
</div>

<script>
// Coder reused
var VSHADER_SOURCE = `
    attribute vec4 a_Position;
    attribute vec4 a_Normal;
    uniform mat4 u_ModelMatrix;
    uniform mat4 u_ViewMatrix;
    uniform mat4 u_ProjMatrix;
    uniform mat4 u_NormalMatrix;
    varying vec3 v_Normal;
    varying vec3 v_Position;
    void main() {
        gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
        v_Position = vec3(u_ModelMatrix * a_Position);
        v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));
    }
`;

// Coder reused
var FSHADER_SOURCE = `
    precision mediump float;
    uniform vec3 u_LightColor1;
    uniform vec3 u_LightPosition1;
    uniform vec3 u_LightColor2;
    uniform vec3 u_LightPosition2;
    uniform vec3 u_AmbientLight;
    uniform vec3 u_DiffuseColor;
    varying vec3 v_Normal;
    varying vec3 v_Position;
    void main() {
        vec3 normal = normalize(v_Normal);
        
        // Light 1
        vec3 lightDirection1 = normalize(u_LightPosition1 - v_Position);
        float nDotL1 = max(dot(lightDirection1, normal), 0.0);
        vec3 diffuse1 = u_LightColor1 * u_DiffuseColor * nDotL1;
        
        // Light 2
        vec3 lightDirection2 = normalize(u_LightPosition2 - v_Position);
        float nDotL2 = max(dot(lightDirection2, normal), 0.0);
        vec3 diffuse2 = u_LightColor2 * u_DiffuseColor * nDotL2;
        
        // Ambient
        vec3 ambient = u_AmbientLight * u_DiffuseColor;
        
        gl_FragColor = vec4(diffuse1 + diffuse2 + ambient, 1.0);
    }
`;

var gl;
var modelMatrix = new Matrix4();
var viewMatrix = new Matrix4();
var projMatrix = new Matrix4();
var normalMatrix = new Matrix4();

var u_ModelMatrix, u_ViewMatrix, u_ProjMatrix, u_NormalMatrix;
var u_LightColor1, u_LightPosition1;
var u_LightColor2, u_LightPosition2;
var u_AmbientLight, u_DiffuseColor;
//main startes here
function main() {
    var canvas = document.getElementById('webgl');
    gl = getWebGLContext(canvas);
    
    if (!gl) {
        console.log('Failed to get WebGL context');
        return;
    }
    
    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to initialize shaders');
        return;
    }
    
    
    u_ModelMatrix = gl.getUniformLocation(gl.program, 'u_ModelMatrix');
    u_ViewMatrix = gl.getUniformLocation(gl.program, 'u_ViewMatrix');
    u_ProjMatrix = gl.getUniformLocation(gl.program, 'u_ProjMatrix');
    u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix');
    u_LightColor1 = gl.getUniformLocation(gl.program, 'u_LightColor1');
    u_LightPosition1 = gl.getUniformLocation(gl.program, 'u_LightPosition1');
    u_LightColor2 = gl.getUniformLocation(gl.program, 'u_LightColor2');
    u_LightPosition2 = gl.getUniformLocation(gl.program, 'u_LightPosition2');
    u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
    u_DiffuseColor = gl.getUniformLocation(gl.program, 'u_DiffuseColor');
    
    // Set view and projection matrices
    viewMatrix.setLookAt(0, 2, 8, 0, 0, 0, 0, 1, 0);
    projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
    gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
    gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
    
    //Set ambient light
    gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
    
    //Set light 2 (constant blue light) cant set to anyif needed 
    gl.uniform3f(u_LightColor2, 0.3, 0.3, 0.8);
    gl.uniform3f(u_LightPosition2, -2.0, 2.0, 3.0);
    
    // Setup sliders
    setupSliders();
    
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    
    draw();
}
// code refered form w3schools
function setupSliders() {
    var lightX = document.getElementById('lightX');
    var lightY = document.getElementById('lightY');
    var lightZ = document.getElementById('lightZ');
    var colorR = document.getElementById('colorR');
    var colorG = document.getElementById('colorG');
    var colorB = document.getElementById('colorB');
    
    lightX.oninput = function() {
        document.getElementById('lightXValue').innerHTML = this.value;
        draw();
    };
    lightY.oninput = function() {
        document.getElementById('lightYValue').innerHTML = this.value;
        draw();
    };
    lightZ.oninput = function() {
        document.getElementById('lightZValue').innerHTML = this.value;
        draw();
    };
    colorR.oninput = function() {
        document.getElementById('colorRValue').innerHTML =this.value;
        draw();
    };
    colorG.oninput = function() {
        document.getElementById('colorGValue').innerHTML = this.value;
        draw();
    };
    colorB.oninput = function() {
        document.getElementById('colorBValue').innerHTML =this.value;
        draw();
    };
}

function draw() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // Get light 1 position from sliders
    var lightX = parseFloat(document.getElementById('lightX').value);
    var lightY = parseFloat(document.getElementById('lightY').value);
    var lightZ = parseFloat(document.getElementById('lightZ').value);
    gl.uniform3f(u_LightPosition1, lightX, lightY, lightZ);
    // Get light 1 color from sliders
    var colorR = parseFloat(document.getElementById('colorR').value);
    var colorG = parseFloat(document.getElementById('colorG').value);
    var colorB = parseFloat(document.getElementById('colorB').value);
    gl.uniform3f(u_LightColor1, colorR, colorG, colorB);
    
    // Draw sphere (red)
    modelMatrix.setTranslate(-1.5, 0, -1);
    drawShape(createSphere(30, 30, 0.8), [0.8, 0.2, 0.2]);
    
    // Draw cylinder (green)
    modelMatrix.setTranslate(0, 0, 0);
    drawShape(createCylinder(30, 20, 0.6, 1.5), [0.2, 0.8, 0.2]);
    
    // Draw cone (blue)
    modelMatrix.setTranslate(1.5, 0, -1);
    drawShape(createCone(30, 20, 0.8, 1.5), [0.2, 0.2, 0.8]);
}

function drawShape(shape, color) {
    initArrayBuffer(shape.vertices, 3, gl.FLOAT, 'a_Position');
    initArrayBuffer(shape.normals, 3, gl.FLOAT, 'a_Normal');
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);
    
    gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
    
    normalMatrix.setInverseOf(modelMatrix);
    normalMatrix.transpose();
    gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements);
    
    gl.uniform3f(u_DiffuseColor, color[0], color[1], color[2]);
    
    gl.drawElements(gl.TRIANGLES, shape.indices.length, gl.UNSIGNED_SHORT, 0);
}

function initArrayBuffer(data, num, type, attribute) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    var a_attribute = gl.getAttribLocation(gl.program, attribute);
    gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);
    gl.enableVertexAttribArray(a_attribute);
}
//refered the link given in assignment
function createSphere(slices, stacks, radius) {
    var vertices = [];
    var normals = [];
    var indices = [];
    for (var i = 0; i <= stacks; i++) {
        var phi = Math.PI * i / stacks;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);
        
        for (var j = 0; j <= slices; j++) {
            var theta = 2 * Math.PI * j / slices;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            
            var x = cosTheta * sinPhi;
            var y = cosPhi;
            var z = sinTheta * sinPhi;
            
            vertices.push(radius * x, radius * y, radius * z);
            normals.push(x, y, z);
        }
    }
    for (var i = 0; i < stacks; i++) {
        for (var j = 0; j < slices; j++) {
            var first = i * (slices + 1) + j;
            var second = first + slices + 1;
            
            indices.push(first, second, first + 1);
            indices.push(second, second + 1, first + 1);
        }
    }
    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}

function createCylinder(slices, stacks, radius, height) {
    var vertices = [];
    var normals = [];
    var indices = [];
    var indexOffset = 0;
    // Side vertices
    for (var i = 0; i <= stacks; i++) {
        var y = (i / stacks - 0.5) * height;
        
        for (var j = 0; j <= slices; j++) {
            var theta = 2 * Math.PI * j / slices;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            
            var x = cosTheta * radius;
            var z = sinTheta * radius;
            
            vertices.push(x, y, z);
            normals.push(cosTheta, 0, sinTheta);
        }
    }
    
    // Side indices
    for (var i = 0; i < stacks; i++) {
        for (var j = 0; j < slices; j++) {
            var first = i * (slices + 1) + j;
            var second = first + slices + 1;
            
            indices.push(first, second, first + 1);
            indices.push(second, second + 1, first + 1);
        }
    }
    
    indexOffset = vertices.length / 3;
    // Top cap
    var topCenterIndex = indexOffset;
    vertices.push(0, height / 2, 0);
    normals.push(0, 1, 0);
    indexOffset++;
    
    for (var j = 0; j <= slices; j++) {
        var theta = 2 * Math.PI * j / slices;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        
        vertices.push(cosTheta * radius, height / 2, sinTheta * radius);
        normals.push(0, 1, 0);
    }
    for (var j = 0; j < slices; j++) {
        indices.push(topCenterIndex, indexOffset + j, indexOffset + j + 1);
    }
    
    indexOffset += slices + 1;
    // Bottom cap // fixed after anouncement
    var bottomCenterIndex = indexOffset;
    vertices.push(0, -height / 2, 0);
    normals.push(0, -1, 0);
    indexOffset++;
    
    for (var j = 0; j <= slices; j++) {
        var theta = 2 * Math.PI * j / slices;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        
        vertices.push(cosTheta * radius, -height / 2, sinTheta * radius);
        normals.push(0, -1, 0);
    }
    
    for (var j = 0; j < slices; j++) {
        indices.push(bottomCenterIndex, indexOffset + j + 1, indexOffset + j);
    }
    
    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}
function createCone(slices, stacks, radius, height) {
    var vertices = [];
    var normals = [];
    var indices =  [];
    // Side vertices
    for (var i = 0; i <= stacks; i++) {
        var y = (i / stacks - 0.5) * height;
        var r = radius * (1 - i / stacks);
        
        for (var j = 0; j <= slices; j++) {
            var theta = 2 * Math.PI * j / slices;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            
            var x = cosTheta * r;
            var z = sinTheta * r;
            
            vertices.push(x, y, z);
            
            var slant = Math.sqrt(radius * radius + height * height);
            var nx = cosTheta * height / slant;
            var ny = radius / slant;
            var nz = sinTheta * height / slant;
            normals.push(nx, ny, nz);
        }
    }
    // Side indices
    for (var i = 0; i < stacks; i++) {
        for (var j = 0; j < slices; j++) {
            var first = i * (slices + 1) + j;
            var second = first + slices + 1;
            
            indices.push(first, second, first + 1);
            indices.push(second, second + 1, first + 1);
        }
    }
    var indexOffset = vertices.length / 3;
    // Bottom cap
    var bottomCenterIndex = indexOffset;
    vertices.push(0, -height / 2, 0);
    normals.push(0, -1, 0);
    indexOffset++;
    for (var j = 0; j <= slices; j++) {
        var theta = 2 * Math.PI * j / slices;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        
        vertices.push(cosTheta * radius, -height / 2, sinTheta * radius);
        normals.push(0, -1, 0);
    }
    for (var j = 0; j < slices; j++) {
        indices.push(bottomCenterIndex, indexOffset + j + 1, indexOffset + j);
    }
    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}
</script>
</body>
</html>