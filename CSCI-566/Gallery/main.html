<!DOCTYPE html>
<html>
<head>
<title>Textured Land Sample with Partial Reflection and Shadows</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/load-object.js"></script>

<script>
var SHADOW_VSHADER_SOURCE =
  `attribute vec4 a_Position;
  uniform mat4 u_MvpMatrix;
  void main() {
    gl_Position = u_MvpMatrix * a_Position;
  }`;

var SHADOW_FSHADER_SOURCE =
  `precision mediump float;
  void main() {
    gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0);
  }`;

var OFFSCREEN_WIDTH = 2048, OFFSCREEN_HEIGHT = 2048;
var LIGHT_X = 15.0, LIGHT_Y = 25.0, LIGHT_Z = 15.0;

var normalProgram, shadowProgram;

var LAND_VSHADER =
  'attribute vec4 a_Position; \n'+
  'attribute vec4 a_Color; \n'+
  'uniform mat4 u_ModelMatrix; \n'+
  'uniform mat4 u_ViewMatrix; \n'+
  'uniform mat4 u_ProjMatrix; \n'+
  'uniform mat4 u_MvpMatrixFromLight; \n'+
  'varying vec4 v_PositionFromLight; \n'+
  'varying vec4 v_Color; \n' +
  'void main() { \n'+
  '  gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; \n'+
  '  v_PositionFromLight = u_MvpMatrixFromLight * a_Position; \n'+
  '  v_Color = a_Color;\n'+
  '}';


var LAND_FSHADER =
  'precision mediump float; \n' +
  'uniform sampler2D u_ShadowMap; \n' +
  'varying vec4 v_PositionFromLight; \n' +
  'varying vec4 v_Color; \n' +
  'void main() { \n' +
  '  vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5; \n' +
  '  vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy); \n' +
  '  float depth = rgbaDepth.r; \n' +
  '  float bias = 0.005; \n' +
  '  float visibility = (shadowCoord.z > depth + bias) ? 0.7 : 1.0; \n' +
  '  vec4 baseColor = v_Color; \n' +
  '  gl_FragColor = vec4(baseColor.rgb * visibility, baseColor.a); \n' +
  '}';

var SKY_VSHADER =
  `precision mediump float;
  attribute vec4 a_Position;
  uniform mat4 u_ModelMatrix; 
  uniform mat4 u_ViewMatrix; 
  uniform mat4 u_ProjMatrix;
  varying vec3 v_Normal;
  void main() { 
    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
    v_Normal = normalize(a_Position.xyz);
  }`;

var SKY_FSHADER =
  `precision mediump float;
  varying vec3 v_Normal;
  uniform samplerCube u_Skybox;
  void main() { 
    gl_FragColor = textureCube(u_Skybox, v_Normal);
  }`;

var TORUS_VSHADER =
  `precision mediump float;
  attribute vec4 a_Position; 
  attribute vec3 a_Normal; 
  attribute vec2 a_UV; 
  attribute vec3 a_Tangent;
  attribute vec3 a_Bitangent;
  uniform mat4 u_ModelMatrix; 
  uniform mat4 u_ViewMatrix; 
  uniform mat4 u_ProjMatrix;
  uniform mat4 u_MvpMatrixFromLight;
  uniform vec3 u_CameraPos; 
  varying vec4 v_Position;
  varying vec4 v_PositionFromLight;
  varying vec3 v_Normal;
  varying vec2 v_UV;
  varying vec3 v_ReflectionDir; 
  varying mat3 v_TBN;
  void main() { 
    gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
    v_Position = u_ModelMatrix * a_Position;
    v_PositionFromLight = u_MvpMatrixFromLight * a_Position;
    v_Normal = vec3(u_ModelMatrix * vec4(a_Normal.xyz,0.0));
    v_UV = a_UV;
    
    vec3 T = normalize(vec3(u_ModelMatrix * vec4(a_Tangent, 0.0)));
    vec3 B = normalize(vec3(u_ModelMatrix * vec4(a_Bitangent, 0.0)));
    vec3 N = normalize(vec3(u_ModelMatrix * vec4(a_Normal, 0.0)));
    v_TBN = mat3(T, B, N);

    vec3 I = normalize(v_Position.xyz - u_CameraPos);
    v_ReflectionDir = reflect(I, normalize(v_Normal));
  }`;

var TORUS_FSHADER =
  `precision mediump float;
  uniform mat4 u_ViewMatrix; 
  uniform samplerCube u_ReflectionMap; 
  uniform sampler2D u_Texture; 
  uniform sampler2D u_NormalMap;
  uniform sampler2D u_ShadowMap;
  uniform vec3 u_CameraPos;
  varying vec4 v_Position; 
  varying vec4 v_PositionFromLight;
  varying vec3 v_Normal;
  varying vec2 v_UV;
  varying vec3 v_ReflectionDir; 
  varying mat3 v_TBN;
  uniform float u_Time; 
  uniform float u_ReflectionFactor; 
  void main() { 
    vec3 ambientColor = vec3(0.3,0.3,0.3);
    vec3 diffuseColor = vec3(0.7,0.7,0.7);
    vec3 specularColor = vec3(1.0,1.0,1.0);

    // Normal Mapping
    vec3 normal = normalize(v_Normal);
    vec3 mapNormal = texture2D(u_NormalMap, vec2(v_UV.s*4.0, v_UV.t)/2.0).rgb;
    mapNormal = normalize(mapNormal * 2.0 - 1.0);
    normal = normalize(v_TBN * mapNormal);

    vec3 lightPos = vec3(${LIGHT_X}.0, ${LIGHT_Y}.0, ${LIGHT_Z}.0); 
    vec3 lightDirection = normalize(lightPos - v_Position.xyz);

    float nDotL = max(dot(lightDirection, normal), 0.0);
    vec3 diffuse = diffuseColor * nDotL;
    
    vec3 toCameraDir = normalize(u_CameraPos - v_Position.xyz); 
    vec3 reflectedLightDir = reflect(-lightDirection, normal);
    float specularBase = clamp(dot(reflectedLightDir, toCameraDir), 0.0, 1.0);
    float specularGloss = pow(specularBase, 16.0);
    vec3 specular = specularColor * specularGloss;
  
    vec3 ambient = ambientColor;

    vec3 baseColor = texture2D(u_Texture, vec2(v_UV.s*4.0, v_UV.t)/2.0).rgb;
    vec3 lighting = (diffuse + specular + ambient) * baseColor;
    
    vec3 reflectionColor = textureCube(u_ReflectionMap, v_ReflectionDir).rgb;
    
    vec3 finalColor = mix(lighting, reflectionColor, u_ReflectionFactor); 
    
    vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5;
    vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);
    float depth = rgbaDepth.r; 
    float visibility = (shadowCoord.z > depth + 0.005) ? 0.7 : 1.0; 
    
    gl_FragColor = vec4(finalColor.rgb * visibility, 1.0);
  }`;

var cameraX = 25.0, cameraY = 5.0, cameraZ = 25.0;
var cameraAngleX = 180.0, cameraAngleY = 0.0;
var velocityY = 0.0;
var isJumping = false;
var GRAVITY = 0.015;
var JUMP_STRENGTH = 0.35;

var moveState = {
  forward: false,
  backward: false,
  left: false,
  right: false
};

var terrainSize = 30;
var TIME = 0.0;
var myJorus;
var myCube;
var myQueen;
var myTeapot;

var fbo;
var viewProjMatrixFromLight;
var mvpMatrixFromLight_j = new Matrix4();
var mvpMatrixFromLight_c = new Matrix4();
var mvpMatrixFromLight_q = new Matrix4();
var mvpMatrixFromLight_t = new Matrix4();
var mvpMatrixFromLight_l = new Matrix4();
var modelMatrix = new Matrix4();

function main() {
  var loadedCount = 0;
  var totalModels = 4;
  
  function checkAllLoaded() {
    loadedCount++;
    if (loadedCount === totalModels) {
      start();
    }
  }
  
  loadJSONResource('jorus.json', function(modelErr, modelObj){
    if (modelErr) { console.error('Error loading jorus:', modelErr); myJorus = null; } else { myJorus = modelObj; }
    checkAllLoaded();
  });
  
  loadJSONResource('cube.json', function(modelErr, modelObj){
    if (modelErr) { console.error('Error loading cube:', modelErr); myCube = null; } else { myCube = modelObj; }
    checkAllLoaded();
  });
  
  loadJSONResource('queen.json', function(modelErr, modelObj){
    if (modelErr) { console.error('Error loading queen:', modelErr); myQueen = null; } else { myQueen = modelObj; }
    checkAllLoaded();
  });
  
  loadJSONResource('teapot.json', function(modelErr, modelObj){
    if (modelErr) { console.error('Error loading teapot:', modelErr); myTeapot = null; } else { myTeapot = modelObj; }
    checkAllLoaded();
  });
}

function start() {
  var canvas = document.getElementById('webgl');
  var gl = getWebGLContext(canvas);
  
  shadowProgram = createProgram(gl, SHADOW_VSHADER_SOURCE, SHADOW_FSHADER_SOURCE);
  shadowProgram.a_Position = gl.getAttribLocation(shadowProgram, 'a_Position');
  shadowProgram.u_MvpMatrix = gl.getUniformLocation(shadowProgram, 'u_MvpMatrix');

  var landProgram = createProgram(gl, LAND_VSHADER, LAND_FSHADER);
  var skyProgram = createProgram(gl, SKY_VSHADER, SKY_FSHADER);
  var torusProgram = createProgram(gl, TORUS_VSHADER, TORUS_FSHADER);
  
  gl.clearColor(0.5, 0.7, 1.0, 1);
  gl.enable(gl.DEPTH_TEST);

  fbo = initFramebufferObject(gl);
  gl.activeTexture(gl.TEXTURE0 + 3);
  gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
  
  viewProjMatrixFromLight = new Matrix4();
  viewProjMatrixFromLight.setPerspective(90.0, OFFSCREEN_WIDTH/OFFSCREEN_HEIGHT, 1.0, 100.0);
  viewProjMatrixFromLight.lookAt(LIGHT_X, LIGHT_Y, LIGHT_Z,  15, 0, 15,  0, 0, 1);

  var landData = initLand(gl, landProgram);
  var skyData = initCube(gl, skyProgram);
  var skyTexture = loadCubeMap(gl, skyProgram, 0);
  
  var jorusData = initTorusFromJSON(gl, torusProgram, myJorus);
  var cubeData = initTorusFromJSON(gl, torusProgram, myCube);
  var queenData = initTorusFromJSON(gl, torusProgram, myQueen);
  var teapotData = initTorusFromJSON(gl, torusProgram, myTeapot);

  // var landTexture = loadLandTexture(gl, landProgram, 1); // Removed
  var reflectionTexture = loadCubeMap(gl, torusProgram, 2);
  var torusTexture = loadTexture(gl, 'pool.jpg', 4);
  var normalMap = loadTexture(gl, 'pool_normal.jpg', 5);
  var rockTexture = loadTexture(gl, 'rock.jpg', 6);
  var rockNormal = loadTexture(gl, 'rock_normal.png', 7);
  var brickTexture = loadTexture(gl, 'brick.jpg', 8);
  var brickNormal = loadTexture(gl, 'brick_normal.png', 9);

  setupControls(canvas);

  var tick = function(){
    updateCameraPosition();
    updatePhysics();
    TIME += 0.2;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.useProgram(shadowProgram);
    
    drawShadow(gl, landData, 0, 0, 0, 30, 0, 30, 'land', landProgram, 0.0);
    drawShadow(gl, jorusData, 15, 3, 15, 2.0, 2.0, 2.0, 'jorus', torusProgram, TIME * 5); 
    drawShadow(gl, cubeData, 10, 3, 10, 1.0, 1.0, 1.0, 'cube', torusProgram, 0.0); 
    drawShadow(gl, queenData, 20, 3, 10, 0.2, 0.2, 0.2, 'queen', torusProgram, 0.0); 
    drawShadow(gl, teapotData, 10, 3, 20, 0.2, 0.2, 0.2, 'teapot', torusProgram, 0); 

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    drawSkybox(gl, skyProgram, skyData, canvas);
    drawLand(gl, landProgram, landData, canvas);
    
    drawTorus(gl, torusProgram, jorusData, canvas, 15, 3, 15, cameraX, cameraY, cameraZ, 2.0, 2.0, 2.0, mvpMatrixFromLight_j, 4, 5, 0.0, TIME * 5); // Added 0.0
    drawTorus(gl, torusProgram, cubeData, canvas, 10, 3, 10, cameraX, cameraY, cameraZ, 1.0, 1.0, 1.0, mvpMatrixFromLight_c, 4, 5, 0.5, 0.0); // Added 0.0
    drawTorus(gl, torusProgram, queenData, canvas, 20, 3, 10, cameraX, cameraY, cameraZ, 0.2, 0.2, 0.2, mvpMatrixFromLight_q, 6, 7, 0.0, 0.0); // Added 0.0
    drawTorus(gl, torusProgram, teapotData, canvas, 10, 3, 20, cameraX, cameraY, cameraZ, 0.2, 0.2, 0.2, mvpMatrixFromLight_t, 8, 9, 0.0, 0); // Added TIME * 50

    requestAnimationFrame(tick);
  };
  tick();
}

function drawShadow(gl, data, posX, posY, posZ, scaleX, scaleY, scaleZ, name, originalProgram, rotationY) {
    if (!data) return;
    modelMatrix.setTranslate(posX, posY, posZ);
    if (name !== 'land') {
        modelMatrix.rotate(rotationY, 0, 1, 0);
        modelMatrix.scale(scaleX, scaleY, scaleZ); 
    }

    var mvpMatrixFromLight = new Matrix4();
    mvpMatrixFromLight.set(viewProjMatrixFromLight).multiply(modelMatrix);
    gl.uniformMatrix4fv(shadowProgram.u_MvpMatrix, false, mvpMatrixFromLight.elements);
    
    if(name === 'jorus') mvpMatrixFromLight_j.set(mvpMatrixFromLight);
    else if(name === 'cube') mvpMatrixFromLight_c.set(mvpMatrixFromLight);
    else if(name === 'queen') mvpMatrixFromLight_q.set(mvpMatrixFromLight);
    else if(name === 'teapot') mvpMatrixFromLight_t.set(mvpMatrixFromLight);
    else if(name === 'land') mvpMatrixFromLight_l.set(mvpMatrixFromLight);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, data.vertexBuffer);
    gl.vertexAttribPointer(shadowProgram.a_Position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(shadowProgram.a_Position);
    
    if(data.indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, data.indexBuffer);
        gl.drawElements(gl.TRIANGLES, data.numIndices, gl.UNSIGNED_SHORT, 0);
    } else {
        gl.drawArrays(gl.TRIANGLES, 0, data.numVertices);
    }
}

function updateCameraPosition() {
  var moveSpeed = 0.15;
  
  if (moveState.forward) {
    cameraX += Math.sin(cameraAngleX) * moveSpeed;
    cameraZ += Math.cos(cameraAngleX) * moveSpeed;
  }
  if (moveState.backward) {
    cameraX -= Math.sin(cameraAngleX) * moveSpeed;
    cameraZ -= Math.cos(cameraAngleX) * moveSpeed;
  }
  if (moveState.left) {
    cameraX += Math.cos(cameraAngleX) * moveSpeed;
    cameraZ -= Math.sin(cameraAngleX) * moveSpeed;
  }
  if (moveState.right) {
    cameraX -= Math.cos(cameraAngleX) * moveSpeed;
    cameraZ += Math.sin(cameraAngleX) * moveSpeed;
  }
  
  cameraX = Math.max(0, Math.min(terrainSize - 1, cameraX));
  cameraZ = Math.max(0, Math.min(terrainSize - 1, cameraZ));
}

function updatePhysics() {
  var terrainHeight = 0;
  
  if (isJumping || cameraY > terrainHeight + 1.5) {
    velocityY -= GRAVITY;
    cameraY += velocityY;
    
    if (cameraY <= terrainHeight + 1.5) {
      cameraY = terrainHeight + 1.5;
      velocityY = 0;
      isJumping = false;
    }
  } else {
    cameraY = terrainHeight + 1.5;
  }
}

function setupControls(canvas) {
  document.addEventListener('keydown', function(ev) {
    switch(ev.key.toLowerCase()) {
      case 'w': moveState.forward = true; break;
      case 's': moveState.backward = true; break;
      case 'a': moveState.left = true; break;
      case 'd': moveState.right = true; break;
      case ' ':
        if (!isJumping && velocityY === 0) {
          velocityY = JUMP_STRENGTH;
          isJumping = true;
        }
        ev.preventDefault();
        break;
    }
  });

  document.addEventListener('keyup', function(ev) {
    switch(ev.key.toLowerCase()) {
      case 'w': moveState.forward = false; break;
      case 's': moveState.backward = false; break;
      case 'a': moveState.left = false; break;
      case 'd': moveState.right = false; break;
    }
  });

  var isMouseDown = false;
  var lastMouseX = 0, lastMouseY = 0;

  canvas.addEventListener('mousedown', function(ev) {
    isMouseDown = true;
    lastMouseX = ev.clientX;
    lastMouseY = ev.clientY;
  });

  document.addEventListener('mouseup', function(ev) {
    isMouseDown = false;
  });

  document.addEventListener('mousemove', function(ev) {
    if (isMouseDown) {
      var deltaX = ev.clientX - lastMouseX;
      var deltaY = ev.clientY - lastMouseY;
      cameraAngleX += deltaX * 0.005;
      cameraAngleY = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, cameraAngleY + deltaY * 0.005));
      
      lastMouseX = ev.clientX;
      lastMouseY = ev.clientY;
    }
  });
}

function drawLand(gl, program, data, canvas) {
  gl.useProgram(program);
  
  var viewMatrix = new Matrix4();
  var projMatrix = new Matrix4();
  
  var u_ModelMatrix = gl.getUniformLocation(program, 'u_ModelMatrix');
  var u_ViewMatrix = gl.getUniformLocation(program, 'u_ViewMatrix');
  var u_ProjMatrix = gl.getUniformLocation(program, 'u_ProjMatrix');
  var u_MvpMatrixFromLight = gl.getUniformLocation(program, 'u_MvpMatrixFromLight');
  var u_ShadowMap = gl.getUniformLocation(program, 'u_ShadowMap');
  
  var lookAtX = cameraX + Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
  var lookAtY = cameraY + Math.sin(cameraAngleY);
  var lookAtZ = cameraZ + Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
  
  viewMatrix.setLookAt(cameraX, cameraY, cameraZ, lookAtX, lookAtY, lookAtZ, 0, 1, 0);
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
  
  projMatrix.setPerspective(60, canvas.width / canvas.height, 0.1, 200);
  gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
  
  modelMatrix.setTranslate(0, 0, 0);
  gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
  
  gl.uniformMatrix4fv(u_MvpMatrixFromLight, false, mvpMatrixFromLight_l.elements);
  gl.uniform1i(u_ShadowMap, 3);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.vertexBuffer);
  var a_Position = gl.getAttribLocation(program, 'a_Position');
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Position);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.colorBuffer);
  var a_Color = gl.getAttribLocation(program, 'a_Color');
  gl.vertexAttribPointer(a_Color, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Color);
  
  gl.drawArrays(gl.TRIANGLES, 0, data.numVertices);
}

function drawSkybox(gl, program, data, canvas) {
  gl.useProgram(program);
  gl.depthFunc(gl.LEQUAL);
  
  var modelMatrix = new Matrix4();
  var viewMatrix = new Matrix4();
  var projMatrix = new Matrix4();
  
  var u_ModelMatrix = gl.getUniformLocation(program, 'u_ModelMatrix');
  var u_ViewMatrix = gl.getUniformLocation(program, 'u_ViewMatrix');
  var u_ProjMatrix = gl.getUniformLocation(program, 'u_ProjMatrix');
  
  var lookAtX = Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
  var lookAtY = Math.sin(cameraAngleY);
  var lookAtZ = Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
  
  viewMatrix.setLookAt(0, 0, 0, lookAtX, lookAtY, lookAtZ, 0, 1, 0); 
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
  
  projMatrix.setPerspective(60, canvas.width / canvas.height, 0.1, 200);
  gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
  
  modelMatrix.setScale(100, 100, 100);
  gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.vertexBuffer);
  var a_Position = gl.getAttribLocation(program, 'a_Position');
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Position);
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, data.indexBuffer);
  gl.drawElements(gl.TRIANGLES, data.numIndices, gl.UNSIGNED_SHORT, 0);
  
  gl.depthFunc(gl.LESS);
}

function drawTorus(gl, program, data, canvas, posX, posY, posZ, camX, camY, camZ, scaleX, scaleY, scaleZ, mvpMatrixFromLight, texUnit, normUnit, reflectionStrength, rotationY) {

  if (!data) return;
  gl.useProgram(program);
  
  var viewMatrix = new Matrix4();
  var projMatrix = new Matrix4();
  
  var u_ModelMatrix = gl.getUniformLocation(program, 'u_ModelMatrix');
  var u_ViewMatrix = gl.getUniformLocation(program, 'u_ViewMatrix');
  var u_ProjMatrix = gl.getUniformLocation(program, 'u_ProjMatrix');
  var u_Time = gl.getUniformLocation(program, 'u_Time');
  var u_ReflectionFactor = gl.getUniformLocation(program, 'u_ReflectionFactor');
  var u_CameraPos = gl.getUniformLocation(program, 'u_CameraPos'); 
  var u_ReflectionMap = gl.getUniformLocation(program, 'u_ReflectionMap'); 
  var u_Texture = gl.getUniformLocation(program, 'u_Texture'); 
  var u_NormalMap = gl.getUniformLocation(program, 'u_NormalMap');
  var u_MvpMatrixFromLight = gl.getUniformLocation(program, 'u_MvpMatrixFromLight');
  var u_ShadowMap = gl.getUniformLocation(program, 'u_ShadowMap');
  
  var lookAtX = cameraX + Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
  var lookAtY = cameraY + Math.sin(cameraAngleY);
  var lookAtZ = cameraZ + Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
  
  viewMatrix.setLookAt(cameraX, cameraY, cameraZ, lookAtX, lookAtY, lookAtZ, 0, 1, 0);
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
  
  projMatrix.setPerspective(60, canvas.width / canvas.height, 0.1, 200);
  gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
  
  gl.uniform1f(u_Time, TIME);
  gl.uniform1f(u_ReflectionFactor, reflectionStrength);
  gl.uniform3f(u_CameraPos, camX, camY, camZ);
  
  gl.uniform1i(u_ReflectionMap, 2); 
  gl.uniform1i(u_Texture, texUnit); 
  gl.uniform1i(u_NormalMap, normUnit);
  gl.uniform1i(u_ShadowMap, 3);
  
  gl.uniformMatrix4fv(u_MvpMatrixFromLight, false, mvpMatrixFromLight.elements);
  
  modelMatrix.setTranslate(posX, posY, posZ);
  modelMatrix.rotate(rotationY, 0, 1, 0);
  modelMatrix.scale(scaleX, scaleY, scaleZ); 
  gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.vertexBuffer);
  var a_Position = gl.getAttribLocation(program, 'a_Position');
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Position);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.normalBuffer);
  var a_Normal = gl.getAttribLocation(program, 'a_Normal');
  gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Normal);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, data.uvBuffer);
  var a_UV = gl.getAttribLocation(program, 'a_UV');
  gl.vertexAttribPointer(a_UV, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_UV);

  gl.bindBuffer(gl.ARRAY_BUFFER, data.tangentBuffer);
  var a_Tangent = gl.getAttribLocation(program, 'a_Tangent');
  gl.vertexAttribPointer(a_Tangent, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Tangent);

  gl.bindBuffer(gl.ARRAY_BUFFER, data.bitangentBuffer);
  var a_Bitangent = gl.getAttribLocation(program, 'a_Bitangent');
  gl.vertexAttribPointer(a_Bitangent, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_Bitangent);
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, data.indexBuffer);
  gl.drawElements(gl.TRIANGLES, data.numIndices, gl.UNSIGNED_SHORT, 0);
}

function initLand(gl, program) {
  var vertices = [];
  var colors = [];

  for (var z = 0; z < terrainSize; z++) {
    for (var x = 0; x < terrainSize; x++) {
      var y = 0;
      
      vertices.push(x, y, z);
      vertices.push(x + 1, y, z);
      vertices.push(x, y, z + 1);
      
      vertices.push(x + 1, y, z);
      vertices.push(x + 1, y, z + 1);
      vertices.push(x, y, z + 1);
      
      for (var i = 0; i < 6; i++) {
        if (x % 2 == 0 && z % 2 == 0) {
          colors.push(0.1, 0.6, 0.2, 1);
        } else {
          colors.push(0.2, 0.7, 0.3, 1);
        }
      }
    }
  }

  var vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  var colorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

  return {
    vertexBuffer: vertexBuffer,
    colorBuffer: colorBuffer,
    numVertices: vertices.length / 3
  };
}

function initCube(gl, program) {
  var vertices = new Float32Array([
      1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0,
      1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0,
      1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0,
     -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0,
     -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0,
      1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0
  ]);

  var indices = new Uint16Array([
      0, 1, 2,   0, 2, 3,    4, 5, 6,   4, 6, 7,
      8, 9,10,   8,10,11,   12,13,14,  12,14,15,
     16,17,18,  16,18,19,   20,21,22,  20,22,23
  ]);

  var vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  var indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  return {
    vertexBuffer: vertexBuffer,
    indexBuffer: indexBuffer,
    numIndices: indices.length
  };
}

function initTorusFromJSON(gl, program, modelObj) {
  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  
  if (modelObj && modelObj.meshes && modelObj.meshes[0]) {
    vertices = Array.from(modelObj.meshes[0].vertices);
    normals = Array.from(modelObj.meshes[0].normals);
    uvs = Array.from(modelObj.meshes[0].texturecoords[0]);
    indices = [].concat.apply([], modelObj.meshes[0].faces);
  } else {
    console.error("Invalid model object for torus.");
    return null;
  }

  var tangents = [];
  var bitangents = [];
  calculateTangents(vertices, normals, uvs, indices, tangents, bitangents);
  
  var vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  
  var normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  
  var uvBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);

  var tangentBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tangentBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tangents), gl.STATIC_DRAW);

  var bitangentBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bitangentBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bitangents), gl.STATIC_DRAW);
  
  var indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  
  return {
    vertexBuffer: vertexBuffer,
    normalBuffer: normalBuffer,
    uvBuffer: uvBuffer,
    tangentBuffer: tangentBuffer,
    bitangentBuffer: bitangentBuffer,
    indexBuffer: indexBuffer,
    numIndices: indices.length
  };
}

function calculateTangents(vertices, normals, uvs, indices, tangents, bitangents) {
  // Initialize tangents and bitangents arrays
  for (var i = 0; i < vertices.length; i++) {
    tangents.push(0);
    bitangents.push(0);
  }

  // Loop through each triangle
  for (var i = 0; i < indices.length; i += 3) {
    var i0 = indices[i];
    var i1 = indices[i + 1];
    var i2 = indices[i + 2];

    var v0 = [vertices[i0 * 3], vertices[i0 * 3 + 1], vertices[i0 * 3 + 2]];
    var v1 = [vertices[i1 * 3], vertices[i1 * 3 + 1], vertices[i1 * 3 + 2]];
    var v2 = [vertices[i2 * 3], vertices[i2 * 3 + 1], vertices[i2 * 3 + 2]];

    var uv0 = [uvs[i0 * 2], uvs[i0 * 2 + 1]];
    var uv1 = [uvs[i1 * 2], uvs[i1 * 2 + 1]];
    var uv2 = [uvs[i2 * 2], uvs[i2 * 2 + 1]];

    var deltaPos1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
    var deltaPos2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];

    var deltaUV1 = [uv1[0] - uv0[0], uv1[1] - uv0[1]];
    var deltaUV2 = [uv2[0] - uv0[0], uv2[1] - uv0[1]];

    var r = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV1[1] * deltaUV2[0]);
    
    if (!isFinite(r)) r = 1.0; // Handle degenerate UVs

    var tangent = [
      (deltaPos1[0] * deltaUV2[1] - deltaPos2[0] * deltaUV1[1]) * r,
      (deltaPos1[1] * deltaUV2[1] - deltaPos2[1] * deltaUV1[1]) * r,
      (deltaPos1[2] * deltaUV2[1] - deltaPos2[2] * deltaUV1[1]) * r
    ];

    var bitangent = [
      (deltaPos2[0] * deltaUV1[0] - deltaPos1[0] * deltaUV2[0]) * r,
      (deltaPos2[1] * deltaUV1[0] - deltaPos1[1] * deltaUV2[0]) * r,
      (deltaPos2[2] * deltaUV1[0] - deltaPos1[2] * deltaUV2[0]) * r
    ];

    // Accumulate tangents and bitangents
    for (var j = 0; j < 3; j++) {
      tangents[i0 * 3 + j] += tangent[j];
      tangents[i1 * 3 + j] += tangent[j];
      tangents[i2 * 3 + j] += tangent[j];

      bitangents[i0 * 3 + j] += bitangent[j];
      bitangents[i1 * 3 + j] += bitangent[j];
      bitangents[i2 * 3 + j] += bitangent[j];
    }
  }

  // Orthogonalize and normalize
  for (var i = 0; i < vertices.length / 3; i++) {
    var n = [normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]];
    var t = [tangents[i * 3], tangents[i * 3 + 1], tangents[i * 3 + 2]];
    
    // Gram-Schmidt orthogonalization
    var dotNT = n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
    var orthoT = [
      t[0] - n[0] * dotNT,
      t[1] - n[1] * dotNT,
      t[2] - n[2] * dotNT
    ];
    
    var lenT = Math.sqrt(orthoT[0] * orthoT[0] + orthoT[1] * orthoT[1] + orthoT[2] * orthoT[2]);
    if (lenT > 0) {
      tangents[i * 3] = orthoT[0] / lenT;
      tangents[i * 3 + 1] = orthoT[1] / lenT;
      tangents[i * 3 + 2] = orthoT[2] / lenT;
    }

    // Normalize bitangent (simplified, ideally should also be orthogonalized or computed via cross product)
    var b = [bitangents[i * 3], bitangents[i * 3 + 1], bitangents[i * 3 + 2]];
    var lenB = Math.sqrt(b[0] * b[0] + b[1] * b[1] + b[2] * b[2]);
    if (lenB > 0) {
      bitangents[i * 3] = b[0] / lenB;
      bitangents[i * 3 + 1] = b[1] / lenB;
      bitangents[i * 3 + 2] = b[2] / lenB;
    }
  }
}

function loadCubeMap(gl, program, textureUnit) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

  const imgSrc = "skybox.png";
  
  const uniformName = (textureUnit === 0) ? 'u_Skybox' : 'u_ReflectionMap'; 
  const u_Sampler = gl.getUniformLocation(program, uniformName);

  const faces = [
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
  ];

  const image = new Image();
  image.onload = function () {
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
    for (let i = 0; i < faces.length; i++) {
      gl.texImage2D(faces[i], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    }
    
    gl.activeTexture(gl.TEXTURE0 + textureUnit);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
    
    gl.useProgram(program);
    gl.uniform1i(u_Sampler, textureUnit);
    
    console.log("Cube map loaded successfully to unit " + textureUnit);
  };

  image.onerror = function () {
    console.error("Failed to load cube map image:", imgSrc);
  };

  image.src = imgSrc;

  return texture;
}



function initFramebufferObject(gl) {
  var framebuffer, texture, depthBuffer;

  framebuffer = gl.createFramebuffer();

  texture = gl.createTexture(); 
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  depthBuffer = gl.createRenderbuffer(); 
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);

  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

  var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  framebuffer.texture = texture;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);

  return framebuffer;
}

function createProgram(gl, vshader, fshader) {
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vshader);
  gl.compileShader(vertexShader);

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fshader);
  gl.compileShader(fragmentShader);

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  return program;
}

function loadTexture(gl, src, textureUnit) {
  var texture = gl.createTexture();
  var image = new Image();
  image.onload = function() {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.activeTexture(gl.TEXTURE0 + textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    console.log("Texture loaded: " + src + " to unit " + textureUnit);
  };
  image.onerror = function() { console.error("Failed to load texture: " + src); };
  image.src = src;
  return texture;
}

</script>

<style>
  body {
    margin: 0;
    padding: 20px;
    font-family: Arial, sans-serif;
    background: #222;
    color: #fff;
  }
  canvas {
    border: 2px solid #fff;
    display: block;
    margin: 0 auto;
    cursor: crosshair;
  }
  .controls {
    text-align: center;
    margin-top: 20px;
    font-size: 14px;
  }
</style>

</head>

<body onload="main();">

<canvas id="webgl" width="800" height="600"></canvas>

<div class="controls">
  <h2>Controls</h2>
  <p><strong>W/A/S/D</strong> - Move Forward/Left/Backward/Right</p>
  <p><strong>Mouse Drag</strong> - Look Around</p>
  <p><strong>Spacebar</strong> - Jump</p>

</div>

</body>
</html>
