

<html><head>

    <title>WebGL Ground with Cube</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
    <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
    <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
    <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>

    <script>
        // Vertex shader (shared)
        var VSHADER_SOURCE =
            'attribute vec4 a_Position; \n'+
            'attribute vec4 a_Color; \n'+
            'uniform mat4 u_ModelMatrix; \n'+
            'uniform mat4 u_ViewMatrix; \n'+
            'uniform mat4 u_ProjMatrix; \n'+
            'varying vec4 v_Position; \n'+
            'varying vec4 v_Color; \n' +
            'void main() { \n'+
            '  gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position; \n'+
            '  v_Position = a_Position;\n'+
            '  v_Color = a_Color;\n'+
            '}';

        // Fragment shader for ground (updated texture)
        var FSHADER_GROUND =
            '#ifdef GL_ES\n' +
            'precision mediump float;\n' +
            '#endif\n' +
            'varying vec4 v_Position; \n' +
            'varying vec4 v_Color; \n' +
            'uniform float u_time; \n' +
            'uniform vec2 u_resolution; \n' +
            
            'float random (in vec2 st) {\n' +
            '    return fract(sin(dot(st.xy,\n' +
            '                         vec2(12.9898,78.233)))*\n' +
            '        43758.5453123);\n' +
            '}\n' +
            
            '// Based on Morgan McGuire @morgan3d\n' +
            '// https://www.shadertoy.com/view/4dS3Wd\n' +
            'float noise (in vec2 st) {\n' +
            '    vec2 i = floor(st);\n' +
            '    vec2 f = fract(st);\n' +
            '    // Four corners in 2D of a tile\n' +
            '    float a = random(i);\n' +
            '    float b = random(i + vec2(1.0, 0.0));\n' +
            '    float c = random(i + vec2(0.0, 1.0));\n' +
            '    float d = random(i + vec2(1.0, 1.0));\n' +
            '    vec2 u = f * f * (3.0 - 2.0 * f);\n' +
            '    return mix(a, b, u.x) +\n' +
            '            (c - a)* u.y * (1.0 - u.x) +\n' +
            '            (d - b) * u.x * u.y;\n' +
            '}\n' +
            
            '#define OCTAVES 6\n' +
            'float fbm (in vec2 st) {\n' +
            '    // Initial values\n' +
            '    float value = 0.0;\n' +
            '    float amplitud = .5;\n' +
            '    float frequency = 0.;\n' +
            '    //\n' +
            '    // Loop of octaves\n' +
            '    for (int i = 0; i < OCTAVES; i++) {\n' +
            '        value += amplitud * noise(st);\n' +
            '        st *= 2.;\n' +
            '        amplitud *= .5;\n' +
            '    }\n' +
            '    return value;\n' +
            '}\n' +
            
            'float edge(float v, float center, float edge0, float edge1) {\n' +
            '    return 1.0 - smoothstep(edge0, edge1, abs(v - center));\n' +
            '}\n' +
            
            'void main() {\n' +
            '    vec2 st = (v_Position.xy + 2.0) / 4.0;\n' +
            '    st.x *= u_resolution.x / u_resolution.y;\n' +
            '    \n' +
            '    float v0 = edge(fbm(st * 18.0), 0.5, 0.0, 0.2);\n' +
            '    float v1 = smoothstep(0.5, 0.51, fbm(st * 14.0));\n' +
            '    float v2 = edge(fbm(st * 14.0), 0.5, 0.0, 0.05);\n' +
            '    float v3 = edge(fbm(st * 14.0), 0.5, 0.0, 0.25);\n' +
            '    \n' +
            '    vec3 col = vec3(1.0);\n' +
            '    col -= v0 * 0.518;\n' +
            '    col = mix(col, vec3(0.618,0.970,0.593), v1);\n' +
            '    col = mix(col, vec3(0.041,0.510,0.047), v2);\n' +
            '    col -= v3 * 0.2;\n' +
            '    \n' +
            '    gl_FragColor = vec4(col,1.0);\n' +
            '}';

        // Fragment shader for cube (simple color)
        var FSHADER_CUBE =
            'precision mediump float; \n' +
            'varying vec4 v_Color; \n' +
            'void main() { \n' +
            '    gl_FragColor = v_Color; \n' +
            '}';

        var gl;
        var groundProgram, cubeProgram;
        var TIME = 0.0;
        var cameraX = 0, cameraY = 2, cameraZ = 6;
        var cameraAngle = 0;
        var cubeIndicesLength = 0;
        var rotationAngle = 0;
        var isPerspective = true;
        var BASE64_IMAGE = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSgBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAEAAQAMBEQACEQEDEQH/xAGiAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgsQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+gEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AKFfIHmmXrv+rh+p/pW9HqVEx63LN2z/AOPWL/dFc8t2YS3HT/6lvpQtxIpVoURv1oGhtIZ0WKwsRcoatGrpHu7E1pTdik2Zn2eP0P51rzMrmYv2qWL5EI2rwOKOVPUOVPUDdzMNrEYPtRyJA4JDfMaggQuT1osXFBuNFh2Oj3r/AHl/OuYxKepMCseCDyehrSA0UKsoqyKxkbAPWrTNFsNCsDyDRcHsPpGYmcdaZURMj1FBRerEyGv2qoghtUMmT7orN7jEl/1bULcEVKsor3P3h9K0iBDVAX/ti/3D+dY8hPII10rfwmmoWDlG/aR/dNVYOU1La3MsCOGADDOK55SsyHOzsLcWxSB23A4FEZXYKepnba2L5iOSAyEEEDFNOwcwz7K394U+cOYgqixRQAUCOm0//jyg/wB0VyT+JnPLdi3n/HrJ9KUPiQluY9dBqKKAFpAUto9K0LuG0elAxdo9KQFyKeVI1VXIAHArNxTZm0rkizyOQruSp6g0cqQrIk8tf7oouK5XuPlYBeOKZUdSLcfU0F2D7LP/AM82qudAI1vMvWMijmQCeRJ/cNF0AeYifKzAMOCKLNisSQyoZVAYEk0mmJrQuZHrUkWIZo3lYGNSwA7UXsVF23I/s03/ADzNF0VzI//Z";

        var vertexBuffer, colorBuffer, texCoordBuffer, floorTexture, texture;
        var cubeVertexBuffer, cubeColorBuffer, cubeIndexBuffer;
        var useTexture = false;

        function main() {
            var canvas = document.getElementById('webgl');
            gl = getWebGLContext(canvas);
            if (!gl) {
                console.log('Failed to get WebGL context');
                return;
            }

            groundProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_GROUND);
            cubeProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_CUBE);
            if (!groundProgram || !cubeProgram) {
                console.log('Failed to create shader');
                return;
            }

            gl.clearColor(0.1, 0.2, 0.4, 1);
            gl.enable(gl.DEPTH_TEST);

            initPlane(gl);
            cubeIndicesLength = initCube(gl);
            setupControls();

            if (BASE64_IMAGE && BASE64_IMAGE.length > 0) {
                initTexture();
            }
            
            tick();
        }

        function initTexture() {
            floorTexture = gl.createTexture();
            var image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, floorTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.bindTexture(gl.TEXTURE_2D, null);
                useTexture = true;
            };
            image.src = BASE64_IMAGE;
        }

        function createProgram(gl, vSource, fSource) {
            var program = gl.createProgram();
            var vShader = loadShader(gl, gl.VERTEX_SHADER, vSource);
            var fShader = loadShader(gl, gl.FRAGMENT_SHADER, fSource);
            gl.attachShader(program, vShader);
            gl.attachShader(program, fShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.log('Failed to link program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log('Failed to compile shader: ' + gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function initPlane(gl) {
            var vertices = new Float32Array([
                -2.0,  2.0,  -0.5,
                -2.0, -2.0,  -0.5,
                 2.0,  2.0,  -0.5,
                 2.0, -2.0,  -0.5,
            ]);

            var texCoords = new Float32Array([
                0.0, 1.0,
                0.0, 0.0,
                1.0, 1.0,
                1.0, 0.0
            ]);

            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        function initArrayBuffer(gl, attribute, data, num) {
            var buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
            
            if (attribute === 'a_Position') {
                cubeVertexBuffer = buffer;
            } else if (attribute === 'a_Color') {
                cubeColorBuffer = buffer;
            }
            
            return true;
        }

        function initCube(gl) {

            // Create a cube
            //    v6----- v5
            //   /|      /|
            //  v1------v0|
            //  | |     | |
            //  | |v7---|-|v4
            //  |/      |/
            //  v2------v3
            var vertices = new Float32Array([
                0.25,  2.0,  0.25+0.5,   -0.25,  2.0,  0.25+0.5,   -0.25, -2.0,  0.25+0.5,    0.25, -2.0,  0.25+0.5,  // front
                0.25,  2.0,  0.25+0.5,    0.25, -2.0,  0.25+0.5,    0.25, -2.0, -0.25+0.5,    0.25,  2.0, -0.25+0.5,  // right
                0.25,  2.0,  0.25+0.5,    0.25,  2.0, -0.25+0.5,   -0.25,  2.0, -0.25+0.5,   -0.25,  2.0,  0.25+0.5,  // top
               -0.25,  2.0,  0.25+0.5,   -0.25,  2.0, -0.25+0.5,   -0.25, -2.0, -0.25+0.5,   -0.25, -2.0,  0.25+0.5,  // left
               -0.25, -2.0, -0.25+0.5,    0.25, -2.0, -0.25+0.5,    0.25, -2.0,  0.25+0.5,   -0.25, -2.0,  0.25+0.5,  // bottom
                0.25, -2.0, -0.25+0.5,   -0.25, -2.0, -0.25+0.5,   -0.25,  2.0, -0.25+0.5,    0.25,  2.0, -0.25 +0.5  // back
            ]);


            var colors = new Float32Array([
                0.3, 0.3, 1.0,  0.3, 0.3, 1.0,  0.3, 0.3, 1.0,  0.3, 0.3, 1.0,  // v0-v1-v2-v3 front(blue)
                0.3, 1.0, 0.3,  0.3, 1.0, 0.3,  0.3, 1.0, 0.3,  0.3, 1.0, 0.3,  // v0-v3-v4-v5 right(green)
                1.0, 0.3, 0.3,  1.0, 0.3, 0.3,  1.0, 0.3, 0.3,  1.0, 0.3, 0.3,  // v0-v5-v6-v1 up(red)
                1.0, 1.0, 0.3,  1.0, 1.0, 0.3,  1.0, 1.0, 0.3,  1.0, 1.0, 0.3,  // v1-v6-v7-v2 left(yellow)
                1.0, 1.0, 1.0,  1.0, 1.0, 1.0,  1.0, 1.0, 1.0,  1.0, 1.0, 1.0,  // v7-v4-v3-v2 down(white)
                0.3, 1.0, 1.0,  0.3, 1.0, 1.0,  0.3, 1.0, 1.0,  0.3, 1.0, 1.0   // v4-v7-v6-v5 back(cyan)
            ]);
            var n = 1.0;
            var UV = new Float32Array([
                n,   n,     0.0, n,     0.0, 0.0,   n,   0.0,    // v0-v1-v2-v3 front
                0.0, n,     0.0, 0.0,   n,   0.0,   n,   n,      // v0-v3-v4-v5 right
                n,   0.0,   n,n,        0.0, n,     0.0, 0.0,    // v0-v5-v6-v1 up
                n,   n,     0.0, n,     0.0, 0.0,   n,   0.0,    // v1-v6-v7-v2 left
                0.0, 0.0,   n,   0.0,   n,   n,     0.0, n,      // v7-v4-v3-v2 down
                0.0, 0.0,   n,   0.0,   n,   n,     0.0, n       // v4-v7-v6-v5 back
            ]);

            var indices = new Uint16Array([
                0, 1, 2,   0, 2, 3,    // front
                4, 5, 6,   4, 6, 7,    // right
                8, 9,10,   8,10,11,    // up
               12,13,14,  12,14,15,    // left
               16,17,18,  16,18,19,    // down
               20,21,22,  20,22,23     // back
            ]);

            initArrayBuffer(gl, 'a_Position', vertices, 3);
            initArrayBuffer(gl, 'a_Color', colors, 3);
            initArrayBuffer(gl, 'a_UV', UV, 2);

            cubeIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            return indices.length;
        }

        function setupPlaneAttributes(program) {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var a_Position = gl.getAttribLocation(program, 'a_Position');
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Position);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            var a_TexCoord = gl.getAttribLocation(program, 'a_TexCoord');
            if (a_TexCoord >= 0) {
                gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(a_TexCoord);
            }
        }

        function setupCubeAttributes(program) {
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
            var a_Position = gl.getAttribLocation(program, 'a_Position');
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Position);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeColorBuffer);
            var a_Color = gl.getAttribLocation(program, 'a_Color');
            gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
        }

        function createBladeColors() {
            var bladeColors = [
                new Float32Array([
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0
                ]),
                new Float32Array([
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0
                ]),
                new Float32Array([
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,
                    0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0
                ]),
                new Float32Array([
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,
                    1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0,  1.0, 1.0, 0.0
                ])
            ];
            
            return bladeColors;
        }

        function tick() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            TIME += 1.0;
            rotationAngle += 2;

            var modelMatrix = new Matrix4();
            var viewMatrix = new Matrix4();
            var projMatrix = new Matrix4();
            var canvas = document.getElementById('webgl');

            var eyeX = cameraX + Math.sin(cameraAngle) * cameraZ;
            var eyeZ = Math.cos(cameraAngle) * cameraZ;
            viewMatrix.setLookAt(eyeX, cameraY, eyeZ, 0, 0, 0, 0, 1, 0);

            if (isPerspective) {
                projMatrix.setPerspective(45, canvas.width/canvas.height, 0.1, 100);
            } else {
                var orthoSize = 5;
                projMatrix.setOrtho(-orthoSize, orthoSize, -orthoSize, orthoSize, 0.1, 100);
            }

            // Draw ground
            gl.useProgram(groundProgram);
            setupPlaneAttributes(groundProgram);
            var u_ModelMatrix = gl.getUniformLocation(groundProgram, 'u_ModelMatrix');
            var u_ViewMatrix = gl.getUniformLocation(groundProgram, 'u_ViewMatrix');
            var u_ProjMatrix = gl.getUniformLocation(groundProgram, 'u_ProjMatrix');
            var u_Time = gl.getUniformLocation(groundProgram, 'u_time');
            var u_Resolution = gl.getUniformLocation(groundProgram, 'u_resolution');
            
            modelMatrix.setTranslate(0, 0, -1);
            modelMatrix.rotate(-90, 1, 0, 0); 
            modelMatrix.scale(1.5, 1.5, 1);   
            gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
            gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
            gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);
            gl.uniform1f(u_Time, TIME);
            gl.uniform2f(u_Resolution, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Draw cubes (windmill)
            gl.useProgram(cubeProgram);
            setupCubeAttributes(cubeProgram);
            u_ModelMatrix = gl.getUniformLocation(cubeProgram, 'u_ModelMatrix');
            u_ViewMatrix = gl.getUniformLocation(cubeProgram, 'u_ViewMatrix');
            u_ProjMatrix = gl.getUniformLocation(cubeProgram, 'u_ProjMatrix');
            
            // Draw main tower cube
            modelMatrix.setTranslate(0, 0.5, 0);
            modelMatrix.scale(0.5, 0.5, 0.5);
            gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
            gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);
            gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);

            gl.drawElements(gl.TRIANGLES, cubeIndicesLength, gl.UNSIGNED_SHORT, 0);

            // Draw 4 windmill blades on top with rotation and different colors
            var bladePositions = [
                [0, 1.9, 0.1],
                [-0.5, 1.4, 0.1],
                [-0.5, 1.4, 0.1],
                [0, 0.9, 0.1]
            ];

            var bladeColors = createBladeColors();
            var bladeColorBuffers = [];

            // Create color buffers for each blade
            for (var i = 0; i < bladeColors.length; i++) {
                bladeColorBuffers[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, bladeColorBuffers[i]);
                gl.bufferData(gl.ARRAY_BUFFER, bladeColors[i], gl.STATIC_DRAW);
            }

            for (var i = 0; i < bladePositions.length; i++) {
                // Setup blade color
                gl.bindBuffer(gl.ARRAY_BUFFER, bladeColorBuffers[i]);
                var a_Color = gl.getAttribLocation(cubeProgram, 'a_Color');
                gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(a_Color);

                modelMatrix.setTranslate(0, 1.4, 0.4);
                modelMatrix.rotate(rotationAngle + (i * 90), 0, 0, 1);
                modelMatrix.translate(bladePositions[i][0] - 0, bladePositions[i][1] - 1.4, 0);
                
                if (i == 1 || i == 2) {
                    modelMatrix.rotate(90, 0, 0, 1);
                } else {
                    modelMatrix.rotate(0, 0, 1, 1);
                }
                    
                modelMatrix.scale(0.3, 0.2, 0.1);
                gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
                gl.drawElements(gl.TRIANGLES, cubeIndicesLength, gl.UNSIGNED_SHORT, 0);
            }

            requestAnimationFrame(tick);
        }

        function setupControls() {
            document.addEventListener('keydown', function(event) {
                switch(event.code) {
                    case 'ArrowUp': moveCamera('forward'); break;
                    case 'ArrowDown': moveCamera('back'); break;
                    case 'ArrowLeft': moveCamera('left'); break;
                    case 'ArrowRight': moveCamera('right'); break;
                }
            });
        }

        function moveCamera(direction) {
            var step = 0.3;
            var angleStep = 0.1;
            switch(direction) {
                case 'forward': cameraZ -= step; break;
                case 'back': cameraZ += step; break;
                case 'left': cameraAngle -= angleStep; break;
                case 'right': cameraAngle += angleStep; break;
            }
        }

        function forward() { moveCamera('forward'); }
        function back() { moveCamera('back'); }
        function left() { moveCamera('left'); }
        function right() { moveCamera('right'); }
        function toggleProjection() {
            isPerspective = !isPerspective;
            var button = document.getElementById('projectionButton');
            button.textContent = isPerspective ? 'Switch to Orthographic' : 'Switch to Perspective';
        }
    </script>
</head>

<body onload="main();">
    <canvas id="webgl" width="600" height="600"></canvas>
    <br><br>
    <button type="button" onclick="forward()">Forward</button>
    <button type="button" onclick="back()">Back</button>
    <button type="button" onclick="left()">Left</button>
    <button type="button" onclick="right()">Right</button>
    <button type="button" id="projectionButton" onclick="toggleProjection()">Switch to Orthographic</button>


</body></html>